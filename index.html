<!DOCTYPE html>
<!-- MDN 재단의 '순수한 자바스크립트를 이용한 2D 벽돌깨기 게임' 문서 참조
https://developer.mozilla.org/ko/docs/Games/Tutorials/%EC%88%9C%EC%88%98%ED%95%9C_%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_2D_%EB%B2%BD%EB%8F%8C%EA%B9%A8%EA%B8%B0_%EA%B2%8C%EC%9E%84 -->

<!-- 추후 재확인 필요한 부분은 (!) 앞에 달아 주석처리해놓음 -->

<html>

  <head>
    <meta charset="utf-8">
    <title>Sangsu's first game - Blockbreak</title>
    <style>
      * {
        padding:0; margin:0;
      }
      /* * 선택자는 모든 element를 대상으로 함 */
      canvas {
        background: #eee;
        display: block;
        margin: 0 auto;
      }
      h1, h3 {
        text-align: center;
        width: 600px;
        margin: auto;
      }
      /* 블록 내 텍스트의 정렬은 text-align, 블록 자체의 정렬은 width 설정 후 margin auto 값 설정 */
    </style>
  </head>

  <body>
    <h1>Sangsu's 벽돌깨기 게임 (PC 버전)</h1>
    <h3>키보드의 ←, → 버튼을 누르거나, 마우스로 조작하시면 됩니다.</h3>
    <h3>패드에 닿을 때마다 빨라지고 박스 하단에 닿으면 게임오버됩니다.</h3>
    <h3>재밌게 플레이하세요 :)</h3>
    <canvas id="myCanvas" width="800" height="600" style="margin-bottom:40px">
      <!-- canvas 태그는 게임이 렌더되는 공간을 생성 -->
    </canvas>

    <script>
      // JavaScript 코드를 작성하는 위치. 대문자/소문자 구분 잘할 것.
      var canvas = document.getElementById("myCanvas");
      // canvas 변수에 <canvas> element에 대한 참조를 저장
      var ctx = canvas.getContext("2d");
      // ctx 변수에 캔버스에 그리는 데 사용되는 도구인 2D rendering context를 저장

      var x = canvas.width/2;
      var y = canvas.height-30;
      // 공의 시작 위치 설정을 위한 위한 x, y 변수 설정

      var dx = 2;
      var dy = -2;
      // 매회 공의 위치 변화를 위한 dx, dy 변수 설정

      var ballRadius = 10;
      // 공이 모서리에 부딪힐 때 공의 중심좌표가 아닌 공의 테두리가 부딪히는 것으로 인식하게 하기 위해 공의 반지름 변수 설정

      var colorArray = ["#003333", "#993366", "#993300", "#006699"];
      var randomcolor = colorArray[Math.floor(Math.random() * colorArray.length)];
      // 색상 랜덤변환 : Stackoverflow 참고 https://stackoverflow.com/questions/4550505/getting-a-random-value-from-a-javascript-array

      var paddleWidth = 75;
      var paddleHeight = 10;
      var paddleX = (canvas.width-paddleWidth)/2;
      var paddleY = (canvas.height-paddleHeight);
      // 공을 치기 위한 paddle의 너비, 높이, 시작 x좌표 설정

      var leftPressed = false;
      var rightPressed = false;
      // 키보드 ← → 버튼이 눌렸는지 확인하기 위한 변수. 처음에는 둘 다 눌리지 않았으므로 false 값으로 설정.

      var brickRowCount = 3;
      var brickColumnCount = 6;
      var brickWidth = 90;
      var brickHeight = 20;
      var brickPadding = 30;
      var brickOffsetTop = 30;
      var brickOffsetLeft = 55;
      // 벽돌 배열의 행과 열의 수, 벽돌의 너비와 높이, 각 벽돌 사이 및 벽돌과 캔버스 모서리와의 간격 변수 설정

      var bricks = [];
      for(var c=0; c<brickColumnCount; c++) {
        bricks[c] = [];
        for(var r=0; r<brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 };
          // 공이 벽돌을 치지 않은 기본 상태를 status 1로 설정
        }
      }
      // c열과 r행을 갖는 bricks 배열을 만든 후, 각 벽돌의 x, y 좌표를 설정
      // ※ ++는 변수를 1 증가시키는 증감 연산자 (a++와 ++a는 차이가 있음 : a++는 다른 연산을 한 후 1을 증가시키고, ++a는 1 증가시킨 후 다른 연산을 함. 참고: https://www.everdevel.com/JavaScript/operator.php)

      var score = 0;
      // 점수기록을 위한 변수 설정

      function drawBall() {
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI*2);
        ctx.fill();
        ctx.closePath();
      }
      // 공을 그리고 색칠하는 함수

      function drawPaddle() {
        ctx.beginPath();
        ctx.rect(paddleX, paddleY, paddleWidth, paddleHeight);
        // ctx.fillStyle = "#0095DD";
        ctx.fill();
        ctx.closePath();
      }
      // paddle을 그리고 색칠하는 함수

      function drawBricks() {
        for(var c=0; c<brickColumnCount; c++) {
          for(var r=0; r<brickRowCount; r++) {
            if(bricks[c][r].status == 1) {
              var brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
              var brickY = (r*(brickHeight+brickPadding))+brickOffsetTop;
              // 벽돌들의 x, y 좌표를 다르게 해주는 변수 설정
              bricks[c][r].x = brickX;
              bricks[c][r].y = brickY;
              ctx.beginPath();
              ctx.rect(brickX, brickY, brickWidth, brickHeight);
              // ctx.fillStyle = "#0095DD";
              ctx.fill();
              ctx.closePath();
            }
          }
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBricks();
        drawBall();
        drawPaddle();
        drawScore();
        collisionDetection();
        // (!) drawPaddle()을 추가하면 공의 색상 변환이 정상 작동하지 않았음. ctx.fillStyle()이 canvas 위의 모든 도형에 대해 색상을 적용하기 때문으로 추정됨.
        // (!)) drawPaddle()에서 ctx.fillStyle()을 제외하면 모서리에 닿았을 때 색상이 다시 바뀌나, 문제는 paddle도 같이 바뀜. 공만 바뀌게 하는 방법 알아보기.
        x += dx;
        y += dy;

        if (x + dx > canvas.width-ballRadius || x + dx < ballRadius) {
          dx = -dx;
        }
        if (y + dy < ballRadius) {
          dy = -dy;
        } else if (y + dy > canvas.height-ballRadius) {
          if(x > paddleX && x < paddleX + paddleWidth) {
            dy = -dy;
            if(dx > 0) {
              dx += 0.4;
            } else if(dx < 0) {
              dx -= 0.4;
            }
            if(dy > 0) {
              dy += 0.4;
            } else if(dy < 0) {
              dy -= 0.4;
            }
          }
          // (exercise) 공의 '테두리'가 paddle에 닿았을 때 공의 속도를 빠르게 함

          else {
            alert("Game Over!");
            // (!) 알림창이 두 개가 연속으로 뜸. 하단 모서리 닫기 직전, 그리고 닿았을 때의 두 번.
            document.location.reload();
          }
          // 공의 '테두리'가 캔버스의 하단 모서리에 닿았을 때, 공의 x 좌표가 paddle의 너비 사이에 있다면 튕겨내는 조건문
        }
        // 공의 '테두리'(정확히는 공의 중심의 x, y좌표에서 ballRadius를 +-한 x, y 값의 집합)가 캔버스의 모서리에 닿았을 때 방향을 바꿔 튕겨나오게 하는 조건문
        // + 공의 '테두리'가 캔버스 하단 모서리에 닿았을 때 "Game Over!" 알림창을 출력하고 알림창을 없애면 페이지를 다시 불러와 게임을 다시 시작하는 조건문.
        if (x + dx == canvas.width-ballRadius || x + dx == ballRadius || y + dy == canvas.height-ballRadius || y + dy == ballRadius) {
          ctx.fillStyle = colorArray[Math.floor(Math.random() * colorArray.length)];
        }
        // (exercise) 공의 테두리가 캔버스의 모서리에 닿았을 때 공의 색상을 바꾸는 조건문
        // (!) ctx.fillStyle = randomcolor로 작성하면 최초 1회만 변경됨. 이 부분에 대한 추가 확인이 필요
        // ※ || 논리 연산자는 3개 이상의 항목도 적용 가능


        if(rightPressed && paddleX < canvas.width - paddleWidth) {
          paddleX += 8;
        } else if(leftPressed && paddleX > 0) {
          paddleX += -8;
        }
        // ← →를 누를 때마다 paddle의 X 좌표를 7씩 바꿈
        // 계속 누르면 화면 밖을 나가게 되므로 paddle의 X 좌표가 캔버스 안에 위치할 때만 좌표를 바꾸도록 && (and) 논리연산자 추가
      }

      document.addEventListener("keydown", keyDownHandler, false);
      document.addEventListener("keyup", keyUpHandler, false);
      // 키보드 중 어떤 키가 눌리면 "keydown" 이벤트가 발생되며, keyDownHandler() 함수 실행. 키에서 손을 떼면 "keyup" 이벤트가 발생하고 keyUpHandler() 함수 실행
      document.addEventListener("mousemove", mouseMoveHandler, false);
      // 마우스를 움직이면 "mousemove" 이벤트가 활성화되며, mouseMoveHandler() 함수 실행

      function keyDownHandler(e) {
        if(e.keyCode == 39) {
          rightPressed = true;
        } else if(e.keyCode == 37) {
          leftPressed = true;
        }
      }

      function keyUpHandler(e) {
        if(e.keyCode == 39) {
          rightPressed = false;
        } else if(e.keyCode == 37) {
          leftPressed = false;
        }
      }
      // →를 누르면 rightPressed를 true로 떼면 false로 바꾸고, ←를 누르면 leftPressed를 true로 떼면 false로 바꾸는 함수
      // (!) 두 함수 모두 e 변수로 표시되는 이벤트를 파라미터로 사용함 (무슨 뜻인지 이해하지 못했음)
      // JavaScript 키보드 Keycode는 https://keycode.info/ 참조

      function mouseMoveHandler(e) {
        var relativeX = e.clientX - canvas.offsetLeft;
        // 마우스 커서의 x 좌표 (e.clientX) - 화면 가장자리와 캔버스 가장자리의 간격을 게임 내에서의 마우스커서의 상대적 x 좌표를 의미하는 relativeX 변수로 설정
        if(relativeX > 0 && relativeX < canvas.width) {
          paddleX = relativeX - paddleWidth/2;
        }
      }
      // 마우스패드의 상대적 좌표가 캔버스의 좌우 사이에 있으면 마우스커서의 좌표에서 paddle 너비의 절반의 왼쪽에 paddle이 그려지는 x 좌표를 지정해주는 if 조건문 설정
      // (exercise) 기존 if 조건문은 마우스를 가장자리로 움직였을 때 paddle의 중심이 가장자리에 닿을때까지 움직이는데, paddle의 모서리와 캔버스 가장자리가 닿을때까지만 움직이게 수정할 것

      function collisionDetection() {
        for(var c=0; c<brickColumnCount; c++) {
          for(var r=0; r<brickRowCount; r++) {
            var b = bricks[c][r];
            if(b.status == 1) {
              if(x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight) {
                dy = -dy;
                b.status = 0;
                score++;
                if(score == brickRowCount*brickColumnCount) {
                  alert("Congratulations! You win! Total Score: "+score);
                  document.location.reload();
                }
                // 모든 벽돌을 다 부수면 게임 이겼다는 메시지가 나오는 if 조건문 추가
              }
              // 공이 벽돌에 충돌했을 때, 즉 공의 x 좌표가 벽돌의 x 좌표와 너비 사이에 있을 때, 그리고 공의 y 좌표가 벽돌의 y 좌표와 높이 사이에 있을 때 방향 전환하는 if 조건문 추가
              // 공이 벽돌에 충돌했을 때 status를 0으로 만드는 조건문 추가 (충돌 시 0의 status가 되어, 그리지 않게 됨)
              // 공이 벽돌에 충돌했을 때 score를 1씩 올리는 코드 추가
              // 벽돌의 윗모서리 아래모서리 부딪히면 정상적으로 작동하나, 옆면으로 들어갈 경우 안에서 겁나 튕겨댐. 양 옆에 충돌할 경우도 판단할 것
            }
          }
        }
      }
      // 각 벽돌들에 대해 충돌을 감지하는 함수 설정. 모든 벽돌을 b 변수로 설정.

      function drawScore() {
        ctx.font = "16px Arial";
        // ctx.fillStyle = "#0095DD";
        ctx.fillText("Score: "+score, 8, 20)
      }
      // 점수를 나타내는 함수 정의

      ctx.fillStyle = "#000000";
      setInterval(draw, 10);
      // setinterval(a,b) : a 함수를 b 간격(단위 ms : 1/1000초)으로 반복실행

    </script>
  </body>
</html>
